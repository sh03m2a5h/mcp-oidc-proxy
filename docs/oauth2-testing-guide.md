# OAuth2実環境テストガイド

## 概要

このドキュメントでは、MCP OIDC Proxyの実際のOAuth2/OIDCプロバイダーでの手動テスト手順とチェック項目を説明します。自動化が困難な実環境でのエンドツーエンドテストを包括的にカバーします。

## 前提条件

### 必要な環境
- MCP OIDC Proxy実行環境
- 実際のバックエンドMCPサーバー（例：claude-desktop）
- Webブラウザ（複数種類推奨）
- ネットワークアクセス（OIDCプロバイダーとの通信）

### テスト用OIDCプロバイダー設定

各プロバイダーごとに以下の設定を準備：

#### 1. Google OAuth2
```yaml
# config.yaml
auth:
  mode: "oidc"
  oidc:
    discovery_url: "https://accounts.google.com/.well-known/openid-configuration"
    client_id: "${GOOGLE_CLIENT_ID}"
    client_secret: "${GOOGLE_CLIENT_SECRET}"
    redirect_url: "http://localhost:8080/callback"
    scopes: ["openid", "email", "profile"]
```

#### 2. Microsoft Azure AD
```yaml
auth:
  oidc:
    discovery_url: "https://login.microsoftonline.com/{tenant-id}/v2.0/.well-known/openid-configuration"
    client_id: "${AZURE_CLIENT_ID}"
    client_secret: "${AZURE_CLIENT_SECRET}"
    redirect_url: "http://localhost:8080/callback"
    scopes: ["openid", "email", "profile"]
```

#### 3. Auth0
```yaml
auth:
  oidc:
    discovery_url: "https://{domain}.auth0.com/.well-known/openid-configuration"
    client_id: "${AUTH0_CLIENT_ID}"
    client_secret: "${AUTH0_CLIENT_SECRET}"
    redirect_url: "http://localhost:8080/callback"
    scopes: ["openid", "email", "profile"]
```

#### 4. Keycloak
```yaml
auth:
  oidc:
    discovery_url: "https://{keycloak-host}/auth/realms/{realm}/.well-known/openid-configuration"
    client_id: "${KEYCLOAK_CLIENT_ID}"
    client_secret: "${KEYCLOAK_CLIENT_SECRET}"
    redirect_url: "http://localhost:8080/callback"
    scopes: ["openid", "email", "profile"]
```

## テストシナリオ

### 基本認証フロー

#### シナリオ1: 正常な認証フロー
**目的**: 基本的なOIDC認証フローが正しく動作することを確認

**手順**:
1. プロキシサーバーを起動
2. ブラウザで `http://localhost:8080/` にアクセス
3. 自動的にOIDCプロバイダーのログイン画面にリダイレクトされることを確認
4. 有効なユーザー認証情報でログイン
5. プロキシにリダイレクトされ、バックエンドサーバーにアクセスできることを確認

**チェック項目**:
- [ ] リダイレクトURLが正しい（HTTPSでない場合の警告含む）
- [ ] PKCE challenge/verifierが正しく生成されている
- [ ] State parameterが正しく設定されている
- [ ] 認証後にセッションCookieが設定される
- [ ] バックエンドサーバーのレスポンスが正常に返される

**期待される動作**:
- ログイン画面への自動リダイレクト
- 認証後の正常なプロキシ機能
- セッション情報のCookie保存

#### シナリオ2: 認証失敗のハンドリング
**目的**: 無効な認証情報での適切なエラーハンドリングを確認

**手順**:
1. プロキシサーバーを起動
2. ブラウザで `http://localhost:8080/` にアクセス
3. 無効なユーザー認証情報でログインを試行
4. エラーレスポンスを確認

**チェック項目**:
- [ ] 認証エラーが適切にハンドリングされる
- [ ] エラーメッセージが表示される
- [ ] ログに適切なエラー情報が記録される
- [ ] セッションが作成されない

### セッション管理

#### シナリオ3: セッション継続性
**目的**: セッションが適切に管理され、再認証が不要なことを確認

**手順**:
1. シナリオ1を実行してログイン状態を確立
2. ブラウザを閉じずに複数のリクエストを送信
3. プロキシサーバーを再起動（セッションストアがメモリの場合）
4. リクエストを再送信

**チェック項目**:
- [ ] ログイン後の複数リクエストで再認証が不要
- [ ] セッションCookieが正しく送信される
- [ ] メモリストア: 再起動後に再認証が必要
- [ ] Redisストア: 再起動後もセッションが維持される

#### シナリオ4: セッション有効期限
**目的**: セッションタイムアウトが正しく動作することを確認

**手順**:
1. シナリオ1を実行してログイン状態を確立
2. 設定したタイムアウト時間まで待機
3. タイムアウト後にリクエストを送信
4. 再認証が要求されることを確認

**チェック項目**:
- [ ] タイムアウト前はアクセス可能
- [ ] タイムアウト後に401エラーまたは再認証画面にリダイレクト
- [ ] 期限切れセッションが適切に削除される

### プロキシ機能

#### シナリオ5: HTTPリクエストプロキシ
**目的**: 認証済みリクエストが正しくバックエンドにプロキシされることを確認

**手順**:
1. シナリオ1を実行してログイン状態を確立
2. 様々なHTTPメソッド（GET, POST, PUT, DELETE）でリクエスト送信
3. リクエストボディとレスポンスを確認
4. カスタムヘッダーの追加を確認

**チェック項目**:
- [ ] GET リクエストが正常にプロキシされる
- [ ] POST リクエストとボディが正常にプロキシされる
- [ ] PUT/DELETE リクエストが正常にプロキシされる
- [ ] レスポンスヘッダーが正しく返される
- [ ] ユーザー情報ヘッダーが追加される（X-User-ID, X-User-Email等）
- [ ] カスタム動的ヘッダーが追加される（X-Request-ID, X-Timestamp等）

#### シナリオ6: WebSocketプロキシ
**目的**: WebSocket接続が正しくプロキシされることを確認

**手順**:
1. シナリオ1を実行してログイン状態を確立
2. WebSocketクライアントでプロキシ経由で接続
3. メッセージの送受信を確認
4. 接続の切断を確認

**チェック項目**:
- [ ] WebSocket Upgradeヘッダーが正しく処理される
- [ ] 双方向通信が正常に動作する
- [ ] 接続が正常に切断される
- [ ] 認証情報がWebSocket接続に引き継がれる

#### シナリオ7: Server-Sent Events (SSE)
**目的**: SSEストリーミングが正しくプロキシされることを確認

**手順**:
1. シナリオ1を実行してログイン状態を確立
2. SSEエンドポイントにアクセス
3. イベントストリームの受信を確認
4. 接続の維持を確認

**チェック項目**:
- [ ] `text/event-stream` Content-Typeが正しく処理される
- [ ] イベントストリームが正常に転送される
- [ ] 長時間接続が維持される
- [ ] 接続の切断が適切に処理される

### エラーハンドリング

#### シナリオ8: バックエンドサーバー停止
**目的**: バックエンドサーバーが利用不可能な場合の動作を確認

**手順**:
1. シナリオ1を実行してログイン状態を確立
2. バックエンドサーバーを停止
3. リクエストを送信
4. エラーレスポンスを確認

**チェック項目**:
- [ ] サーキットブレーカーが動作する
- [ ] 適切なエラーコード（502 Bad Gateway）が返される
- [ ] エラーログが出力される
- [ ] リトライロジックが動作する

#### シナリオ9: ネットワーク遅延
**目的**: ネットワーク遅延やタイムアウトの処理を確認

**手順**:
1. ネットワーク遅延をシミュレート（tc コマンド等）
2. シナリオ1を実行
3. レスポンス時間とタイムアウト処理を確認

**チェック項目**:
- [ ] 設定されたタイムアウト時間で接続が切断される
- [ ] 適切なエラーメッセージが表示される
- [ ] プロキシが応答不能にならない

### セキュリティテスト

#### シナリオ10: CSRF攻撃対策
**目的**: CSRF攻撃に対する保護が機能することを確認

**手順**:
1. 別ドメインからのコールバックURLアクセスを試行
2. 無効なstateパラメータでのアクセスを試行
3. 正常な認証フローとの比較

**チェック項目**:
- [ ] 無効なstateパラメータが拒否される
- [ ] Origin/Refererヘッダーがチェックされる
- [ ] CSRF攻撃が防御される

#### シナリオ11: セッション固定攻撃対策
**目的**: セッション固定攻撃に対する保護を確認

**手順**:
1. 未認証状態でセッションCookieを取得
2. そのCookieを使用して認証フローを実行
3. 認証後のセッションIDが変更されることを確認

**チェック項目**:
- [ ] 認証後にセッションIDが更新される
- [ ] 古いセッションIDが無効化される

### マルチブラウザテスト

#### シナリオ12: ブラウザ間互換性
**目的**: 複数ブラウザでの動作を確認

**テスト対象ブラウザ**:
- Chrome/Chromium
- Firefox
- Safari（macOSの場合）
- Edge

**チェック項目**:
各ブラウザで以下を確認:
- [ ] 認証フローが正常に動作する
- [ ] Cookie処理が正しい
- [ ] WebSocket/SSE機能が動作する
- [ ] JavaScript（ある場合）が正常に動作する

### パフォーマンステスト

#### シナリオ13: 同時接続テスト
**目的**: 複数ユーザーの同時アクセスを確認

**手順**:
1. 複数のブラウザ/セッションで同時にアクセス
2. それぞれ独立して認証を実行
3. プロキシのパフォーマンスを確認

**チェック項目**:
- [ ] 複数セッションが独立して管理される
- [ ] レスポンス時間が大幅に劣化しない
- [ ] メモリリークが発生しない

## テスト環境の設定

### 1. ローカル開発環境
```bash
# プロキシ起動
cd go
export OIDC_DISCOVERY_URL="..."
export OIDC_CLIENT_ID="..."
export OIDC_CLIENT_SECRET="..."
make run

# バックエンドMCPサーバー起動（別ターミナル）
npx @modelcontextprotocol/server-everything
```

### 2. Docker環境
```bash
# docker-compose.ymlで設定
docker-compose up -d
```

### 3. Cloudflare Tunnel環境
```bash
# プロダクションライクなテスト
cloudflared tunnel --url http://localhost:8080
```

## トラブルシューティング

### よくある問題と解決方法

#### 認証リダイレクトループ
**症状**: ログイン画面とコールバック間で無限ループ
**確認項目**:
- リダイレクトURLの設定
- セッションCookieのドメイン設定
- HTTPSの使用（本番環境）

#### セッションが保持されない
**症状**: 毎回再認証が要求される
**確認項目**:
- Cookie設定（SameSite, Secure属性）
- セッションストアの動作
- ブラウザのCookie設定

#### プロキシが動作しない
**症状**: 認証後もバックエンドにアクセスできない
**確認項目**:
- バックエンドサーバーの起動状態
- プロキシ設定（ホスト、ポート）
- ネットワーク接続

## 自動化のヒント

### テスト結果の記録
```bash
# ログ出力の保存
./mcp-oidc-proxy 2>&1 | tee test-$(date +%Y%m%d-%H%M%S).log

# メトリクス取得
curl http://localhost:8080/metrics > metrics-$(date +%Y%m%d-%H%M%S).txt
```

### 設定の切り替え
```bash
# 複数プロバイダーのテスト自動化
for provider in google azure auth0; do
    echo "Testing $provider"
    export CONFIG_FILE="config-${provider}.yaml"
    ./test-oauth-flow.sh
done
```

## レポートテンプレート

### テスト結果記録表

| シナリオ | 実行日 | 結果 | ブラウザ | プロバイダー | 備考 |
|---------|--------|------|----------|-------------|------|
| 基本認証フロー | | ✅/❌ | Chrome | Google | |
| セッション継続性 | | ✅/❌ | Firefox | Azure | |
| WebSocketプロキシ | | ✅/❌ | Safari | Auth0 | |

### 問題報告テンプレート
```markdown
## 問題の概要
[簡潔な問題の説明]

## 再現手順
1. [手順1]
2. [手順2]
3. [手順3]

## 期待される動作
[期待していた動作]

## 実際の動作
[実際に発生した動作]

## 環境情報
- OS: 
- ブラウザ: 
- プロバイダー: 
- 設定: 

## ログ
```
[関連するログの抜粋]
```

## エラーメッセージ
[エラーメッセージがあれば]
```

## まとめ

このガイドに従って体系的にテストを実行することで、OAuth2/OIDC実装の品質と信頼性を確保できます。各シナリオのチェック項目を確実に実行し、問題があれば適切に記録・報告してください。

特に本番環境デプロイ前には、実際に使用するOIDCプロバイダーでの包括的なテストを必ず実施してください。